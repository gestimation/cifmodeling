% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/polyreg.R
\name{polyreg}
\alias{polyreg}
\title{Fit regression models of cumulative incidence functions based on polytomous
log-odds products and stratified IPCW estimator}
\usage{
polyreg(
  nuisance.model,
  exposure,
  strata = NULL,
  data,
  subset.condition = NULL,
  na.action = na.omit,
  code.event1 = 1,
  code.event2 = 2,
  code.censoring = 0,
  code.exposure.ref = 0,
  effect.measure1 = "RR",
  effect.measure2 = "RR",
  time.point = NULL,
  outcome.type = "COMPETING-RISK",
  conf.level = 0.95,
  report.nuisance.parameter = FALSE,
  report.optim.convergence = FALSE,
  report.sandwich.conf = TRUE,
  report.boot.conf = NULL,
  boot.bca = FALSE,
  boot.parameter1 = 200,
  boot.parameter2 = 46,
  nleqslv.method = "nleqslv",
  optim.parameter1 = 1e-06,
  optim.parameter2 = 1e-06,
  optim.parameter3 = 100,
  optim.parameter4 = 50,
  optim.parameter5 = 50,
  optim.parameter6 = 50,
  optim.parameter7 = 1e-10,
  optim.parameter8 = 1e-06,
  optim.parameter9 = 1e-06,
  optim.parameter10 = 40,
  optim.parameter11 = 0.025,
  optim.parameter12 = 2,
  optim.parameter13 = 0.5,
  data.initial.values = NULL,
  should.normalize.covariate = TRUE,
  should.terminate.time.point = TRUE,
  prob.bound = 1e-05
)
}
\arguments{
\item{nuisance.model}{A \code{\link[stats]{formula}} describing the outcome and
nuisance covariates, excluding the exposure of interest.}

\item{exposure}{A character string giving the name of the categorical exposure
variable in \code{data}.}

\item{strata}{Optional character string with the name of the stratification
variable used to adjust for dependent censoring. Defaults to \code{NULL}.}

\item{data}{A data frame containing the outcome, exposure and nuisance
covariates referenced by \code{nuisance.model}.}

\item{subset.condition}{Optional expression (as a character string) defining a
subset of \code{data} to analyse. Defaults to \code{NULL}.}

\item{na.action}{A function specifying the action to take on missing values.
The default is \code{\link[stats]{na.omit}}.}

\item{code.event1}{Integer code corresponding to the first event of interest.
Defaults to \code{1}.}

\item{code.event2}{Integer code corresponding to the competing event. Defaults
to \code{2}.}

\item{code.censoring}{Integer code representing censoring. Defaults to
\code{0}.}

\item{code.exposure.ref}{Integer code identifying the reference exposure
category. Defaults to \code{0}.}

\item{effect.measure1}{Character string specifying the effect measure for the
primary event. Supported values are \code{"RR"}, \code{"OR"} and
\code{"SHR"}.}

\item{effect.measure2}{Character string specifying the effect measure for the
competing event. Supported values are \code{"RR"}, \code{"OR"} and
\code{"SHR"}.}

\item{time.point}{Numeric time point at which the exposure effect is
evaluated. Required for survival and competing risk analyses.}

\item{outcome.type}{Character string selecting the outcome type. Valid values
are \code{"COMPETING-RISK"}, \code{"SURVIVAL"}, \code{"BINOMIAL"},
\code{"PROPORTIONAL"} and \code{"POLY-PROPORTIONAL"}. Defaults to
\code{"COMPETING-RISK"}.
If \code{NULL} (default), the function automatically infers the outcome type
from the data: if the event variable has more than two unique levels,
\code{"COMPETING-RISK"} is assumed; otherwise, \code{"SURVIVAL"} is used.
You can also use abbreviations such as \code{"S"} or \code{"C"}.
Mixed or ambiguous inputs (e.g., \code{c("S", "C")}) trigger automatic
detection based on the event coding in \code{data}.}

\item{conf.level}{Confidence level for Wald-type intervals. Defaults to
\code{0.95}.}

\item{report.nuisance.parameter}{Logical; if \code{TRUE}, the returned object
includes estimates of the nuisance model parameters. Defaults to
\code{FALSE}.}

\item{report.optim.convergence}{Logical; if \code{TRUE}, optimisation
convergence summaries are returned. Defaults to \code{FALSE}.}

\item{report.sandwich.conf}{Logical or \code{NULL}. When \code{TRUE}, confidence
intervals based on sandwich variance are computed. When \code{FALSE}, they are
omitted. Defaults to \code{TRUE}.}

\item{report.boot.conf}{Logical or \code{NULL}. When \code{TRUE}, bootstrap
confidence intervals are computed. When \code{FALSE}, they are omitted. If
\code{NULL}, the function chooses based on \code{outcome.type}.}

\item{boot.bca}{Logical indicating the bootstrap confidence interval method.
Use \code{TRUE} for bias-corrected and accelerated intervals or \code{FALSE}
for the normal approximation. Defaults to \code{FALSE}.}

\item{boot.parameter1}{Integer giving the number of bootstrap replications.
Defaults to \code{200}.}

\item{boot.parameter2}{Numeric seed used for resampling of bootstrap.}

\item{nleqslv.method}{Character string defining the solver used by
\code{\link[nleqslv]{nleqslv}}. Available choices include \code{"nleqslv"},
\code{"Broyden"}, \code{"Newton"}, \code{"optim"}, \code{"BFGS"} and
\code{"SANN"}.}

\item{optim.parameter1}{Numeric tolerance for convergence of the outer loop.
Defaults to \code{1e-6}.}

\item{optim.parameter2}{Numeric tolerance for convergence of the inner loop.
Defaults to \code{1e-6}.}

\item{optim.parameter3}{Numeric constraint on the absolute value of
parameters. Defaults to \code{100}.}

\item{optim.parameter4}{Integer maximum number of outer loop iterations.
Defaults to \code{50}.}

\item{optim.parameter5}{Integer maximum number of \code{nleqslv}
iterations per outer iteration. Defaults to \code{50}.}

\item{optim.parameter6}{Integer maximum number of iterations for the
Levenberg-Marquardt routine. Defaults to \code{50}.}

\item{optim.parameter7}{Numeric convergence tolerance for the
Levenberg-Marquardt routine. Defaults to \code{1e-10}.}

\item{optim.parameter8}{Numeric tolerance for updating the Hessian in the
Levenberg-Marquardt routine. Defaults to \code{1e-6}.}

\item{optim.parameter9}{Numeric starting value for the Levenberg-Marquardt
damping parameter lambda. Defaults to \code{1e-6}.}

\item{optim.parameter10}{Numeric upper bound for lambda in the
Levenberg-Marquardt routine. Defaults to \code{40}.}

\item{optim.parameter11}{Numeric lower bound for lambda in the
Levenberg-Marquardt routine. Defaults to \code{0.025}.}

\item{optim.parameter12}{Numeric multiplicative increment applied to lambda
when the Levenberg-Marquardt step is successful. Defaults to \code{2}.}

\item{optim.parameter13}{Numeric multiplicative decrement applied to lambda
when the Levenberg-Marquardt step is unsuccessful. Defaults to \code{0.5}.}

\item{data.initial.values}{Optional data frame providing starting values for
the optimisation. Defaults to \code{NULL}.}

\item{should.normalize.covariate}{Logical indicating whether covariates should
be centred and scaled prior to optimization. Defaults to \code{TRUE}.}

\item{should.terminate.time.point}{Logical indicating whether time points
that contribute estimation are terminated by min of max follow-up times
of each exposure level. Defaults to \code{TRUE}.}

\item{prob.bound}{Numeric lower bound used to truncate probabilities away
from 0 and 1. Defaults to \code{1e-5}.}
}
\value{
A list containing fitted exposure effects and supporting results. The
main components include \code{coefficient} (estimated exposure and
covariate effects), \code{cov} (their variance-covariance matrix),
\code{summary} (a tidy summary table compatible with
\code{\link[modelsummary]{msummary}}) and \code{diagnostic.statistics}
(inverse probability weights, influence functions and predicted potential
outcomes).
}
\description{
Fits regression models and estimates multiplicative effects of
a categorical exposure under several outcome types, including competing risks,
survival and binomial outcomes
}
\details{
\subsection{Overview}{

\code{polyreg()} fits regression models for cumulative incidence (AJ), survival (KM),
or binomial outcomes using \strong{polytomous log-odds products}. Specify the outcome
on the LHS of \code{nuisance.model} via \code{Event(time, status)} (competing risks/survival)
or a 0/1 response (binomial). The categorical \strong{exposure} is named with the
\code{exposure} argument (levels are inferred from \code{data} and compared against
\code{code.exposure.ref}).
}

\subsection{Outcome type and time point}{
\itemize{
\item \code{outcome.type}: \code{"COMPETING-RISK"} (Aalen–Johansen), \code{"SURVIVAL"} (Kaplan–Meier),
\code{"BINOMIAL"}, \code{"PROPORTIONAL"}, or \code{"POLY-PROPORTIONAL"}.
\item \code{time.point}: required for \code{"COMPETING-RISK"} and \code{"SURVIVAL"}; ignored for
\code{"BINOMIAL"}/\code{"PROPORTIONAL"} families.
}
}

\subsection{Event/status coding}{

Use integer codes to map your data to analysis types:\tabular{lll}{
   Setting \tab Codes \tab Meaning \cr
   Competing risk \tab \code{code.event1}, \code{code.event2}, \code{code.censoring} \tab event of interest / competing event / censor \cr
   Survival (KM) \tab \code{code.event1}, \code{code.censoring} \tab event / censor \cr
   ADaM-ADTTE \tab \code{code.event1 = 0}, \code{code.censoring = 1} \tab set to match ADaM convention \cr
}


The \strong{stratification} variable \code{strata} (optional) adjusts for dependent
censoring in IPCW-style steps when applicable.
}

\subsection{Effect measures (categorical exposure)}{

Choose the effect scale for event 1 and (optionally) event 2:\tabular{llll}{
   Argument \tab Applies to \tab Choices \tab Default \cr
   \code{effect.measure1} \tab primary event \tab \code{"RR"}, \code{"OR"}, \code{"SHR"} \tab \code{"RR"} \cr
   \code{effect.measure2} \tab competing event \tab \code{"RR"}, \code{"OR"}, \code{"SHR"} \tab \code{"RR"} \cr
}

\itemize{
\item \code{RR}: risk ratio at \code{time.point} (AJ/KM contexts).
\item \code{OR}: odds ratio on the log-odds-product parameterization.
\item \code{SHR}: subdistribution hazard ratio (interpreted in the log-odds-product model).
}
}

\subsection{Inference and intervals}{\tabular{lll}{
   Argument \tab Meaning \tab Default \cr
   \code{conf.level} \tab Wald-type CI level \tab \code{0.95} \cr
   \code{report.sandwich.conf} \tab Sandwich variance CIs \tab \code{TRUE} \cr
   \code{report.boot.conf} \tab Bootstrap CIs (if \code{TRUE} or \code{NULL} with suitable outcome) \tab \code{NULL} \cr
   \code{boot.bca} \tab Use BCa intervals (else normal approx) \tab \code{FALSE} \cr
   \code{boot.parameter1} \tab Bootstrap reps \tab \code{200} \cr
   \code{boot.parameter2} \tab Seed for resampling \tab \code{46} \cr
}


Notes:
\itemize{
\item If both sandwich and bootstrap are requested, results may be reported side by side.
\item For heavy data, prefer sandwich CIs; use bootstrap to probe small-sample robustness.
}
}

\subsection{Optimization & solver controls (advanced)}{

\code{polyreg()} solves estimating equations with optional inner routines.\tabular{lll}{
   Argument \tab Role \tab Default \cr
   \code{nleqslv.method} \tab Root solver / optimizer backend \tab \code{"nleqslv"} \cr
   \code{optim.parameter1} / \code{optim.parameter2} \tab Outer/inner convergence tolerances \tab \code{1e-6}, \code{1e-6} \cr
   \code{optim.parameter3} \tab Parameter absolute bound \tab \code{100} \cr
   \code{optim.parameter4} \tab Max outer iterations \tab \code{50} \cr
   \code{optim.parameter5} \tab Max \code{nleqslv} iters per outer \tab \code{50} \cr
   \code{optim.parameter6:13} \tab Levenberg–Marquardt controls (iters/tolerances/lambda) \tab see defaults \cr
}


Tips:
\itemize{
\item If convergence warnings appear, relax/tighten tolerances or cap the parameter
bound (\code{optim.parameter3}). Inspect \code{report.optim.convergence = TRUE}.
}
}

\subsection{Data handling and stability}{\tabular{lll}{
   Argument \tab Meaning \tab Default \cr
   \code{subset.condition} \tab An expression (as character) to subset \code{data} \tab \code{NULL} \cr
   \code{na.action} \tab NA handling function \tab \code{stats::na.omit} \cr
   \code{should.normalize.covariate} \tab Center/scale nuisance covariates \tab \code{TRUE} \cr
   \code{should.terminate.time.point} \tab Truncate support by exposure-wise follow-up maxima \tab \code{TRUE} \cr
   \code{prob.bound} \tab Truncate probabilities away from 0/1 (numerical guard) \tab \code{1e-5} \cr
   \code{data.initial.values} \tab Optional starting values data frame \tab \code{NULL} \cr
}

}

\subsection{Returned object and downstream use}{

The result is a list containing:
\itemize{
\item \code{coefficient} and \code{cov}: estimates and variance–covariance matrix.
\item \code{summary}: a tidy data frame (ready for \code{modelsummary::msummary()}), with
effect sizes and intervals on the chosen scale (\code{RR}/\code{OR}/\code{SHR}).
\item \code{diagnostic.statistics}: IPCW weights, influence functions, and predicted
potential outcomes for diagnostics and sensitivity checks.
}

You can visualize model-implied curves with \code{cifplot()} (by passing fitted
objects or re-using the same \code{Event()}/\code{Surv()} specification).
}

\subsection{Reproducibility and conventions}{
\itemize{
\item Set \code{boot.parameter2} for reproducible bootstrap results.
\item Match CDISC ADaM conventions via \code{code.event1 = 0}, \code{code.censoring = 1}
(and, if applicable, \code{code.event2} for competing events).
\item Use \code{strata} when censoring may depend on baseline factors (IPCW stratification).
}
}
}
\examples{
data(diabetes.complications)
output <- polyreg(
  nuisance.model = Event(t, epsilon) ~ +1,
  exposure = "fruitq1",
  data = diabetes.complications,
  effect.measure1 = "RR",
  effect.measure2 = "RR",
  time.point = 8,
  outcome.type = "COMPETING-RISK"
)
if (requireNamespace("modelsummary", quietly = TRUE)) {
modelsummary::msummary(output$summary, statistic = c("conf.int", "p.value"), exponentiate = TRUE)
}
}
